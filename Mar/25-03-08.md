# 오늘 내가 배운 것들(Today I Learned)

- `streamlit` 소개 및 사용법을 익혔다
- 5주차 미니퀘스트 진행을 하였다.(CNN)

---

## 왜 streamlit 을 쓰는가? 

- AI 웹 어드민(admin, 관리) 개발하려고
- fastapi 는 백엔드랑 협업할때 사용
    
    > streamlit : 연습용
    > fastapi : 실전용

- `streamlit` 은 동적이라서 generation 이 매번 업데이트가 됨 -> 시각화가 편하고 직관적이다

## Session State

- 세션이라는 주제로 논의가 시작된다
- Q. web 세션이 뭘까?
    - 사용자가 웹사이트에 접속하면 세션ID 생성
    - 사용자가 웹사이트를 방문하고 사용할때 유지되는 상태 정보임
    - 사용자의 장바구니 및 폼 입력 데이터를 유지!

- Q. 세션이 필요한 이유는?
    - HTTP는 무상태(Stateless) 프로토콜이므로 요청과 응답이 끝나면 연결정보가 사라짐
    - 하지만, 로그인 상태 유지나 장바구니 기능처럼 지속적인 사용자 정보를 유지해야하는 경우가 있음
    - 이를 해결하기 위해 `Session`을 사용!

- 세션의 동작 방식
    - 세션 생성 -> 세션 저장 -> 세션 유지 -> 세션 종료

    1. 세션 생성 : 사용자가 웹사이트에 처음 접속하면 서버가 세션을 생성하고 `고유한 세션 ID`를 발급함
    2. 세션 저장 : 서버는 세션 ID를 사용하여 사용자의 데이터를 저장
    3. 세션 유지 : 사용자가 요청을 보낼때마다 `세션 ID가 포함` 되어 있어서 해당 세션을 유지 및 상태 기억함
    4. 세선 종료 : 사용자가 `로그아웃` 및 일정시간이 지나면 세션 만료

- Q. 그럼 세션을 저장하는 방법은?

    1. 서버 메모리 (Session Storage)
        - 세션 정보를 `서버의 메모리` 에 저장
        - 속도가 빠르지만, 사용량에 따라 메모리 과부화가 올수도 있음(트래픽 증가)
    2. 데이터베이스(DB) 저장
        - 세션 정보를 DB에 저장하는 방식
        - 서버가 재시작되어도 데이터가 유지되지만, DB부하가 발생할 수 있음!
    3. 쿠키 기반 저장
        - 세션 ID를 `쿠키` 에 저장하고, 필요한 정보를 `클라이언트`(사용자의 브라우저)에 저장하는 방식

            > 클라이언트 : 서버에 요청을 보내고 응답을 받는 소프트웨어 또는 장치를 의미
            > 일반적으로 **브라우저(Chrome,Edge,Safari)** 가 클라이언트 역할임
        - 서버 부담이 적지만, 보안 위험(쿠키 변조, 탈취등) 이 존재

- FastAPI와 Streamlit에서 세션 관리

    - FastAPI: 백엔드에서 JWT(JSON Web Token) 또는 세션 기반 인증을 활용하여 사용자 인증과 상태를 유지할 수 있음
        - Q. JWT가 뭐지?
            > JWT(JSON Web Token) : 사용자 인증 및 정보 교환을 위해 사용되는 `토큰 기반` 인증 방식임

            > 서버에서 세션을 저장하지 않고 **클라이언트기 직접 보관** 하는 방식임
        - JWT의 구성 : .(점)으로 구분된 3개의 부분으로 이루어져 있음
            1. Header(헤더): 토큰의 타임(JWT)과 서명 알고리즘(예: HS256)을 포함
            2. Payload(페이로드): 사용자의 정보(예 : user_id), 만료 시간(exp)등 주요 데이터를 포함
            3. Signature (서명): Header 와 Payload를 조합한 뒤, 비밀키로 `암호화` 하여 위변조 방지
        - JWT의 동작 방식
            1. 사용자가 로그인하면, **서버가 JWT를 생성** 하여 클라이언트(사용자 브라우저 등)에 전달
            2. 클라이언트는 JWT를 **로컬 저장소(Local Storage)** 또는 **쿠키** 에 저장
            3. 사용자가 인증이 필요한 요청을 보낼 때, **JWT를 함께 전달**
            4. 서버는 JWT의 서명을 검증하여 사용자가 인증된 상태인지 확인 , 확인되면 요청 처리
        > 세션기반 인증과 JWT 방식은 서로 다르며 동시에 사용은 안함!

        - Q. 그럼 쿠키(Cookie) 및 캐시가 JWT기반의 클라이언트 인증 방식인가?
            - 쿠키&캐시는 JWT 기반 인증과 관련이 있지만, 직접적인 인증 방식은 아님.
            - 쿠키(Cookie)와 JWT
                - 쿠키는 클라이언트(브라우저)가 서버에서 받은 데이터를 저장하는 방식임
                - 서버는 JWT 발급 후 **쿠키에 저장 할수도 있고, 않을수도 있음**
                - 클라이언트가 서버에 요청할 때, **쿠키에 저장된 JWT를 자동으로 포함하여 보낼수 있음**
            - 캐시(Cashe)와 JWT
                - 캐시는 **인증을 수행하는 방식**이 아니라, JWT를 저장하여 성능을 향상시키는 **보조 도구**이다
                - JWT 자체는 클라이언트에서 직접 관리하지만, **JWT 검증 결과를 캐시에 저장할 수 있다**
                - 서버에서 **JWT의 검증결과를 캐시에 저장**하여, 같은 JWT를 다시 검증할 필요 없게 만듬

	- Streamlit: 기본적으로 상태를 유지하지 않지만, st.session_state를 사용하여 세션 데이터를 관리할 수 있음
    
---

## 5주차(CNN) 미니퀘스트

| **숫자(Label)** | **원-핫 벡터 표현**                 |
| ------------- | ------------------------------ |
| 0             | [1, 0, 0, 0, 0, 0, 0, 0, 0, 0] |
| 1             | [0, 1, 0, 0, 0, 0, 0, 0, 0, 0] |
| 2             | [0, 0, 1, 0, 0, 0, 0, 0, 0, 0] |
| 3             | [0, 0, 0, 1, 0, 0, 0, 0, 0, 0] |
| 4             | [0, 0, 0, 0, 1, 0, 0, 0, 0, 0] |
| 5             | [0, 0, 0, 0, 0, 1, 0, 0, 0, 0] |
| 6             | [0, 0, 0, 0, 0, 0, 1, 0, 0, 0] |
| 7             | [0, 0, 0, 0, 0, 0, 0, 1, 0, 0] |
| 8             | [0, 0, 0, 0, 0, 0, 0, 0, 1, 0] |
| 9             | [0, 0, 0, 0, 0, 0, 0, 0, 0, 1] |

- '원-핫 백터'는 클래스(0~9)에 해당하는 위치만 1로 설정하고, 나머지는 0으로 표현하는 방식이다

- CNN에서 데이터 흐름 (크기 증가 → 줄이기 반복)
    - CNN은 합성곱(convolution) -> 풀링(Pooling) 을 반복하여 특징을 추출한다
    - 이 과정에서 이미지를 넓히고(픽셀 증가), 다시 줄이고(풀링) 하는 과정이 반복된다

- 과정
    1. Conv2D -> 특징 확장 (채널 수 증가, 더 많은 패턴 감지)
    2. MaxPooling -> 특징 보존하면서 크기 감소
        > 연산량 줄이고 과적합 방지
    3. 다시 Conv2D -> 더 고차원 특징 학습(필터 수 증가)
    4. 다시 MaxPooling -> 크기 최적화 (연산 최적화)
    5. Flatten 후 Dense 층으로 전달 -> 최종 분류 수행