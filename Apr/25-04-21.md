# 오늘 내가 배운 것들(Today I Learned)

- 모의 면접 공부 및 정리
- 아키텍처 보완 및 수정 진행

---

# DateBase

1. RDB와 NoSQL의 차이점?
- RDB(Relational Data Base)는 구조화된 데이터와 정적 스키마를 가지며 복잡한 쿼리 및 ACID 트랜잭션을 지원
-  NoSQL(Not0 Only SQL)은 다양한 데이터 모델과 동적 스키마, 수평 확장 및 BASE 모델을 통해 높은 확장성과 유연성을 제공

###  1) NoSQL의 강점과 약점이 뭐냐?

-  이름에도 알 수 있듯이 SQL 뿐만 아니라 다양한 데이터를 처리할 수 있고 대량의 데이터 처리와 더 많은 트래픽을 지원하기 쉽다
- SQL과 같은 표준 언어를 갖추고 있지 않아 복잡한 쿼리의 실행이 어려울 수 있고 분산 환경에서 일관성 보장이 되지 않을 수 있음 또한 ACID 특징을 지원하지 않는 경우가 있음

    >>  ACID가 뭐냐?

    >> Atomicity/ Consistency/ Isolation/ Durability

    >> DB에서 트랜잭션의 신뢰성을 보장하기 위한 4가지 원칙을 뜻함

| **약어** | **이름**                | **설명**                                                     |
| ------ | --------------------- | ---------------------------------------------------------- |
| **A**  | **Atomicity (원자성)**   | 트랜잭션은 **모두 성공하거나, 모두 실패해야 함**중간에 멈추면 이전 상태로 되돌림 (rollback) |
| **C**  | **Consistency (일관성)** | 트랜잭션이 끝난 뒤에도 DB는 **항상 올바른 상태**여야 함                         |
| **I**  | **Isolation (격리성)**   | 동시에 여러 트랜잭션이 수행되어도 **서로 간섭 없이 독립적으로 실행**되어야 함              |
| **D**  | **Durability (지속성)**  | 트랜잭션이 성공하면 그 결과는 **절대 사라지지 않음** (시스템이 꺼져도 데이터는 유지됨)        |

    >> SQL(Structured Query Language) : 언어다^^

    >> 정형 데이터(행/열 구조의 데이터)를 다루기 위한 표준 데이터베이스 언어임

\### 2)  DDL, DML. DCL 이 뭐냐?

-  DDL(Data Definition Language) : **데이터베이스 구조**를 정의, 수정, 삭제하는 명령어

    >>  CREATE, ALTER, DROP 등

- DML(Data Manipulate Language) : 데이터값을 **변경 & 새로운 데이터를 생성**하는 명령어

    >> INSERT, UPDATE, DELETE 등

- DCL(Data Control Language) : 데이터베이스 **접근 권한과 보안을 관리**하는 명령어

    >> GRANT, REVOKE 등 

###  스키마

-  데이터베이스에 어떤 구조로 데이터가 저장되는지 나타내는 데이터 베이스 구조임
    - 정적 스키마(SQL) : 데이터베이스에 저장되는 데이터의 구조가 **미리 정의된 스키마이**며 데이터 구조가 명확해서 데이터 관리 & 무결성 보장이 쉬움 But, 정적이다 보니 데이터 구조 변경이 어렵고 유연성도 낮음
    - 동적 스키마(NoSQL) : 데이터 베이스에 저장되는 **데이터의 구조가 런타임에 결정되는** 스키마이며 데이터 구조를 유연하게 변경할 수 있고 유연성이 높지ㅇㅇ But, 데이터 관리가 아무래도 어렵겠지? 무결성 보장도 어렵고

        >>> 데이터의 구조가 런타임에 결정? 뭔소리지

        >>>  아 미리 컬럼을 정하지 않아도 되서

        >>> 런타임(실행 중)에 어떤 데이터 구조든 넣을 수 있다는 뜻임!!!

---

##  Leafresh

- 챗봇에 RAG기법을 통해 챌린치 추천이 좀더 개연성 높고 근거있게 제공하기 위해서 사용하기로 결정함

## **2. LLM 단독 사용의 한계 (Grounding 부족 문제)**

| **한계**      | **설명**                             |
| ----------- | ---------------------------------- |
| 중구난방한 추천 가능 | LLM은 훈련 데이터만 바탕으로 일반화된 응답을 생성함     |
| 근거 부족       | 왜 이 챌린지를 추천했는지 명확한 출처 없이 말함        |
| 최신성 부족      | 예: “챌린지 목록이 바뀌었는데 여전히 옛날 기준으로 추천함” |

## **3. RAG의 적용 효과 (기술 논문 및 실사용 근거)**

>> RAG는 LLM에게 문서 기반 ‘context’를 줌으로써, 그 문서 안에서 답을 하도록 유도합니다. 이건 단순히 prompt를 잘 만드는 것과는 차원이 다름

- 대표 논문:
    - [Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks – Lewis et al. (2020)](https://arxiv.org/abs/2005.11401)

        → “RAG improves factual accuracy and interpretability by anchoring generation to specific sources.”

    - [LlamaIndex & LangChain 실사용 가이드](https://docs.llamaindex.ai/)

        → RAG 기반 챗봇이 “같은 질문이라도 문서에 따라 답변이 달라지고, 설명이 명확해짐”

    #  React

    - React를 프로젝트에 도입해야 하는 이유는?
        - 자바스크립트 기반의 라이브러리 또는 프레임워크를 선정함에 있어서, React를 사용하는  여러 이유중 대표적으로 가상 DOM, 생태계, 컴포넌트 기반의 개발 당의 이유가 있다. 
        - 먼저 가상 DOM을 통해서 실제 DOM과 차이가 나는 부분만 re-랜더링 함으로써, 효과적인 랜더링을 경험할 수 있도록 함
        - 프론트엔드 개발 도구 중에 가장 큰 생태계를 가지고 있어 다양한 참고 자료가 많으므로 개발 함에 유리함
        - 컴포넌트 기반의 개발 방식은 컴포넌트를 재사용하고 분리할 수 있어 코드의 관리와 유지보수가 쉽다. 따라서 프로젝트의 규모가 커질수록 확장성적인 측면에도 유리함

---

# DOM이 뭐지 돔? 

- DOM(Document Object Model)은 웹 페이지의 구조를 표현 하는 방식임
- 쉽게 말하면 HTML 요소들을 트리 구조로 표현한 객체다
    - 예를 들어 아래와 같은 HTML이 있다고 가정:

```html
<body>
  <h1>안녕하세요</h1>
  <p>React 공부중입니다.</p>
</body>
```

- 이 HTML은 브라우저 안에서 다음과 같은 `DOM트리` 로 바뀜 :

```html
Document
 └── body
     ├── h1 ("안녕하세요")
     └── p ("React 공부중입니다.")
```

- DOM이라고 하는 것은 브라우저 안에서 화면을 그리는 기본 구조임을 알 수 있음!

    ## 컴포넌트(Component)란?

    -  React에서는 화면을 구성하는 작은 조각들을 `컴포넌트`라고 부름
    - 일종의 재사용이 가능한 UI 묶음이라고 할 수 있다

    ###  랜더링(Rendering)이란?

    - 랜더링은 간단히 말해 사용자에게 보여지는 화면을 만드는 `과정` 이다!
    - 브라우저가 HTML, CSS, JS 등을 분석해서 실제 눈에 보이는 형태로 화면을 그리는 것

    ###  그렇다면 리랜더링(Re-rendering)이란?

    -  리랜더링은 어떤 `상태` 나 `데이터` 가 바뀔 때, 화면에서 **바뀐 내용만 다시 그리는 것**

    ###  가상 DOM(Virtual DOM)이란?

    -  실제 DOM은 무겁고 느릴 수 있다 -> React는 DOM을 직접 다루지 않고 **가상의 DOM트리를 메모리에 만들어서 먼저 계산**하고, **진짜 DOM과 비교(diff)** 해서 바뀐 부분만 최소화로 갱신!!! -> “보다 동적이고 빠른 성능을 제공하는 UI의 핵심 비결이다”

    ### 생명주기(Life cycle API)란?

    - React에서 말하는 `생명주기`는 컴포넌트가 생성 & 업데이트 & 사라지는 **전체과정을 말한다**
    - 약간 컴포넌트가 “테어나고,->변화하고->죽는" 단계를 걸치는 그런 느낌
    - 그러면 생명주기가 왜 중요할까
        - 개발자들이 생명주기의 특정시점에 특정코드를 실행할 수 있음
            - 컴포넌트가 화면에 처음 나타날때 -> 데이터 불러오기
            - 컴포넌트가 업데이트 될 때 -> 상태에 따라 UI반응
            - 컴포넌트가 사라질 떼 -> 리소스 정리(ex. 타이머 제거, 구독 해제 등)

    ### Props(properties)와 State 의 공통점 및 차이점은?

    - 큰 틀에서 변경을 통해 랜덩링의 트리거 역할을 한다는 공통점이 있음

        > 랜더링의 트리거?

        > Props 혹은 State가 변경되면, 해당 컴포넌트는 자동으로 다시 랜더링 된다는 뜻  

| **항목**       | **설명**                               |
| ------------ | ------------------------------------ |
| 역할           | 컴포넌트 안에서 데이터를 사용해서 화면(UI)을 구성하는 데 쓰임 |
| 반응형          | 값이 바뀌면 해당 컴포넌트는 자동으로 **리렌더링**됨       |
| 컴포넌트 내부에서 사용 | JSX에서 {} 안에 넣어서 값 참조 가능              |

- React의 핵심 특징은 **데이터가 바뀌면 화면도 자동으로 바뀐다**는 점임
- 차이점?
- Props는 부모 -> 자식 으로 데이터넘겨주는 외부 데이터 형태이고

    >  부모가 자식에게 전닳한 값이 바뀌면, 자식 컴포넌트도 리랜더링

- State는 말그대로 `상태` 이므로 각자 자기가 수정하며 관리가 가능한 형태

| **구분**   | **Props**                 | **State**                             |
| -------- | ------------------------- | ------------------------------------- |
| 정의       | 부모 → 자식에게 넘겨주는 **외부 데이터** | 컴포넌트 내부에서 선언하는 **내부 상태**              |
| 수정 가능 여부 | **읽기 전용** (자식은 수정 불가)     | **수정 가능** (setState, useState)        |
| 사용 목적    | 컴포넌트 간 **데이터 전달**         | 사용자 인터랙션에 따라 **UI 상태 관리**             |
| 소유자      | 부모 컴포넌트                   | 자신(자식) 컴포넌트                           |
| 예시       | <Profile name="지훈" />     | const [count, setCount] = useState(0) |

###  Context API 란?

-  Context는 컴포넌트 트리 구조에서 데이터를 **상위 컴포넌트에서 하위 컴포넌트로** 효율적인 전달과 공유를 위한 기능임
    - 공급자 & 소비자 관계로서 Context API를 사용하여 같은 Context를 공유하는 컴포넌트 간의 훅을 통해 같은 상태를 사용할 수 있게 만들어 주는 기능임

--- 

# DateBase

1. RDB와 NoSQL의 차이점?
- RDB(Relational Data Base)는 구조화된 데이터와 정적 스키마를 가지며 복잡한 쿼리 및 ACID 트랜잭션을 지원
-  NoSQL(Not0 Only SQL)은 다양한 데이터 모델과 동적 스키마, 수평 확장 및 BASE 모델을 통해 높은 확장성과 유연성을 제공

###  1.1 NoSQL의 강점과 약점이 뭐냐?

-  이름에도 알 수 있듯이 SQL 뿐만 아니라 다양한 데이터를 처리할 수 있고 대량의 데이터 처리와 더 많은 트래픽을 지원하기 쉽다
- SQL과 같은 표준 언어를 갖추고 있지 않아 복잡한 쿼리의 실행이 어려울 수 있고 분산 환경에서 일관성 보장이 되지 않을 수 있음 또한 ACID 특징을 지원하지 않는 경우가 있음

    >>  ACID가 뭐냐?

    >> Atomicity/ Consistency/ Isolation/ Durability

    >> DB에서 트랜잭션의 신뢰성을 보장하기 위한 4가지 원칙을 뜻함

| **약어** | **이름**                | **설명**                                                     |
| ------ | --------------------- | ---------------------------------------------------------- |
| **A**  | **Atomicity (원자성)**   | 트랜잭션은 **모두 성공하거나, 모두 실패해야 함**중간에 멈추면 이전 상태로 되돌림 (rollback) |
| **C**  | **Consistency (일관성)** | 트랜잭션이 끝난 뒤에도 DB는 **항상 올바른 상태**여야 함                         |
| **I**  | **Isolation (격리성)**   | 동시에 여러 트랜잭션이 수행되어도 **서로 간섭 없이 독립적으로 실행**되어야 함              |
| **D**  | **Durability (지속성)**  | 트랜잭션이 성공하면 그 결과는 **절대 사라지지 않음** (시스템이 꺼져도 데이터는 유지됨)        |

> SQL(Structured Query Language) : 언어다^^

> 정형 데이터(행/열 구조의 데이터)를 다루기 위한 표준 데이터베이스 언어임

### 2.1 DDL, DML. DCL 이 뭐냐?

-  DDL(Data Definition Language) : **데이터베이스 구조**를 정의, 수정, 삭제하는 명령어

    > CREATE, ALTER, DROP 등

- DML(Data Manipulate Language) : 데이터값을 **변경 & 새로운 데이터를 생성**하는 명령어

    > INSERT, UPDATE, DELETE 등

- DCL(Data Control Language) : 데이터베이스 **접근 권한과 보안을 관리**하는 명령어

    > GRANT, REVOKE 등 

###  스키마

-  데이터베이스에 어떤 구조로 데이터가 저장되는지 나타내는 데이터 베이스 구조임
    - 정적 스키마(SQL) : 데이터베이스에 저장되는 데이터의 구조가 **미리 정의된 스키마이**며 데이터 구조가 명확해서 데이터 관리 & 무결성 보장이 쉬움 But, 정적이다 보니 데이터 구조 변경이 어렵고 유연성도 낮음
    - 동적 스키마(NoSQL) : 데이터 베이스에 저장되는 **데이터의 구조가 런타임에 결정되는** 스키마이며 데이터 구조를 유연하게 변경할 수 있고 유연성이 높지ㅇㅇ But, 데이터 관리가 아무래도 어렵겠지? 무결성 보장도 어렵고

        > 데이터의 구조가 런타임에 결정? 뭔소리지

        >  아 미리 컬럼을 정하지 않아도 되서

        > 런타임(실행 중)에 어떤 데이터 구조든 넣을 수 있다는 뜻임!!!

---

##  Leafresh

- 챗봇에 RAG기법을 통해 챌린치 추천이 좀더 개연성 높고 근거있게 제공하기 위해서 사용하기로 결정함

## **2. LLM 단독 사용의 한계 (Grounding 부족 문제)**

| **한계**      | **설명**                             |
| ----------- | ---------------------------------- |
| 중구난방한 추천 가능 | LLM은 훈련 데이터만 바탕으로 일반화된 응답을 생성함     |
| 근거 부족       | 왜 이 챌린지를 추천했는지 명확한 출처 없이 말함        |
| 최신성 부족      | 예: “챌린지 목록이 바뀌었는데 여전히 옛날 기준으로 추천함” |

## **3. RAG의 적용 효과 (기술 논문 및 실사용 근거)**

> RAG는 LLM에게 문서 기반 ‘context’를 줌으로써, 그 문서 안에서 답을 하도록 유도합니다. 이건 단순히 prompt를 잘 만드는 것과는 차원이 다름

- 대표 논문:
    - [Retrieval-Augmented Generation for Knowledge-Intensive NLP Tasks – Lewis et al. (2020)](https://arxiv.org/abs/2005.11401)

        > “RAG improves factual accuracy and interpretability by anchoring generation to specific sources.”

    - [LlamaIndex & LangChain 실사용 가이드](https://docs.llamaindex.ai/)

        > RAG 기반 챗봇이 “같은 질문이라도 문서에 따라 답변이 달라지고, 설명이 명확해짐”

---

- 아래는 아키텍처 수정본이다.

## 아키텍처

<img width="850" alt="Image" src="https://github.com/user-attachments/assets/c6e08a9c-a234-4211-a25d-9439f2cb8e5a" />

<br>

### 1-1. 각 모듈의 책임(Domain)과 기능

| 모듈 | 설명 | 분리 이유 |
|------|------|-----------|
| **Backend (BE)** | 모델 호출, 챌린지 등록/조회 처리 | 다양한 AI/DB 연계 및 확장성 확보 |
| **LLM ChatBot** | 챌린지 추천 (카테고리 기반/자유 입력 기반) | LLM 비용 최적화 및 챗봇 로직 분리 |
| **LLM Feedback** | 챌린지 참여 결과 피드백 생성               | 개인/단체 챌린지 성공/실패 이력을 기반으로 코멘트 생성 |
| **LLM Censor**   | 챌린지 중복 여부 판단 및 필터링                 | 기존 챌린지와 유사 여부 비교 → 생성 가능 여부 판단 |
| **LLM Verify**   | 이미지 기반 인증 판단                         | 업로드된 인증 사진에 대해 성공/실패 여부 판독 |
| **Message Queue** | 이미지 인증 비동기 처리 | 안정적 분산 처리 및 확장성 확보 |
| **Database** | 사용자, 챌린지, 인증 결과 저장 | 영속성 및 조회 기능 담당 |
| **Output Guardrails** | 출력 포맷 및 유해성 검증                | 응답 JSON 포맷 확인, 필터링 및 Fallback 처리 |
| **Context Construction** | Query Rewriting + RAG Retrieval    | freetext 입력을 구조화하고 관련 문서 검색 후 포함 |
| **ChromaDB** | 벡터 임베딩 기반 문서 저장소 | 유사 질문 대응, 대화 문맥 강화, <br />챗봇의 응답 정확도 향상을 위해 사용

### 1-2. Output Guardrails 분류

 - ChatBot_Output Guardrails : ChatBot 응답 검열 및 포맷 보정
 - FeedBack_Output Guardrails : FeedBack 응답 검열 및 포맷 보정
 - ChatBot 및 FeedBack 모델에서만 Output Guardrails를 적용한 이유
      - ChatBot과 Feedback 모델은 사용자의 입력에 대해 LLM의 자연어 응답을 그대로 사용자 UI에 출력하는 구조이기 때문
      - 응답의 품질 및 안정성을 확보하기 위해 Guardrails가 반드시 필요
      - 그 외 LLM 응답이 JSON으로 파싱되지 않거나, 필수 필드가 누락된 경우, 예외처리로 오류 감지 및 기본 응답으로 대체 필요
<br>

### 2. 모듈 간 인터페이스 설계 (API 명세 및 데이터 포맷)

| API 경로 | 호출 방향 
|----------|-----------
| `POST /ai/verify-image` | Backend → LLM Verify 
| `POST /ai/verify-result` | LLM Verify → Backend 
| `POST /ai/chatbot/select-category` | Backend → LLM Chatbot 
| `POST /ai/chatbot/freetext` | Backend → LLM Chatbot 
| `POST /ai/validate-challenge` | Backend → LLM Censor
| `POST /ai/feedback` | Backend → LLM Feedback 
| (Message Queue 처리) | LLM Verify <-> Queue 
| (DB 저장) | Backend → Database 

<br>

### 3. 모듈화로 기대되는 효과와 장점

- 도메인 책임 분리 (SRP) : 기능별 LLM을 분리함으로써 개발, 테스트, 배포 범위 최소화
- 확장성 높은 구조 : 새로운 기능 추가 시 다른 모듈에 영향 없이 병렬 확장 가능
- 에러 영향 최소화 : 한 모듈의 장애가 전체 시스템에 전파되지 않음
- 성능 튜닝 최적화 : 모델별 Prompt/토큰/메모리 튜닝이 개별화 가능

<br>
 
### 4. 모듈화된 설계가 팀의 서비스 시나리오에 부합하는 이유

| 변화 시나리오 | 변경 대상 모듈 | 영향을 받는 범위 |
|--------------------------|----------------------|------------------------|
| 챌린지 추천 정책 변경 | `ChatBot LLM` | LLM만 fine-tune, 다른 모듈 영향 없음 |
| 챌린지 생성 시 검열 기준 변경 | `Censor LLM` | 검열 LLM만 교체, Backend/DB 영향 없음 |
| 이미지 추론 모델 업그레이드 | `AI Model` | 모델만 교체 가능, 인증 로직 전체 유지 |
| DB 스키마 변경 | `Database`, `Backend` | 프론트/LLM/모델 영향 없음 |

- `ChatBot`은 사용자의 추천 요청에만 반응하고, `Feedback`, `Censor`, `Verify`는 각기 독립적으로 동작
- 예시: 챌린지 생성 정책이 변경되어도 `LLM Censor`만 업데이트하면 되며, `ChatBot`, `Feedback`은 영향 없음

<br>

