# 오늘 내가 배운 것들(Today I Learned)

- 오늘은 팀프로젝트에 대비하여 클라우드 전체흐름에 대해 알아보았다.
- 우선, 비용 절약을 위해 GCP서버를 쓴다음, AWS 서버로 변환한다고 결정이 났다.

---

- ## **Cloud Run 기본 구조**

    > ✔️ **내 모델을 컨테이너로 만들어 Cloud Run에 배포**

    > ✔️ **Cloud Run이 URL(API 엔드포인트)**을 만들어줌

    > ✔️ **사용자가 그 URL로 사진을 업로드하면 → 내 모델이 받아서 추론**

    > ✔️ **그 결과를 사용자에게 즉시 응답(response)으로 돌려줌**

- Webhook 방식은 따로 정의해보면
    - 사용자가 결과를 이 경로로 받고 싶을때, url POST를 서버에다가 보내는 방식이고, 이를 통해 결과(콜백)을 해당 url로 받음

    ```markdown
    사용자 → 내 Cloud Run URL 로 사진 + callback_url 전송
    내 서버 → 결과 분석 후 그 callback_url로 POST 전송
    ```

| **항목**     | **기본 구조 (Cloud Run API)** | **Webhook 구조**                   |
| ---------- | ------------------------- | -------------------------------- |
| 응답 방식      | 사용자 요청에 **즉시 응답**         | 결과를 **다른 주소로 따로 POST**           |
| 요청에 포함된 정보 | 이미지 등                     | 이미지 + callback_url               |
| 응답 타이밍     | 바로                        | 나중에                              |
| 구현 난이도     | 쉬움                        | 약간 더 설정 필요                       |
| 사용 예시      | REST API, 웹앱 요청           | 외부 시스템 연동 (예: 슬랙 알림, 결제 완료 알림 등) |

---

- 그래서 문득 도커에서의 컨테이너 배포 및 전체적인 아키텍쳐가 궁금해졌다.

    # **전체 아키텍처 그림으로 보기**

    ```markdown
    [1] 개발자 (당신)
        |
        | 📦 내 모델 + API 코드 + 종속성 => 도커 컨테이너 이미지 생성
        ↓
    [2] 컨테이너 이미지 저장소 (Google Artifact Registry or Docker Hub)
        |
        | 🚀 이미지 지정해서 Cloud Run에 배포 요청
        ↓
    [3] Cloud Run
        |
        | 🌐 HTTPS 엔드포인트(URL)를 생성
        ↓
    [4] 사용자
        |
        | 📸 사진 업로드 요청 (POST /predict)
        ↓
    [5] Cloud Run 내 컨테이너
        |
        | 🤖 내 모델이 이미지 판독
        ↓
    [6] 결과 반환
    ```

- GCP의 Cloud Run은 도커 컨테이너를  받아서, 서버로 만들어주는 서비스임.

| **구성 요소**         | **설명**                                    |
| ----------------- | ----------------------------------------- |
| Dockerfile        | 컨테이너 만들기 위한 설명서 (Python 설치, FastAPI 실행 등) |
| main.py           | 예측 처리하는 FastAPI/Flask 코드                  |
| model.pt          | 저장된 학습 모델 파일                              |
| requirements.txt  | 필요한 Python 패키지 리스트                        |
| Cloud Run         | GCP에서 컨테이너를 받아서 **서버처럼 운영해주는 서비스**        |
| Artifact Registry | 컨테이너 이미지 저장소 (GCP 전용 Docker Hub 같은 것)     |

    - 아 모르겠다 이미지 빌드라는것은 뭘까? 한번 알아보자

| **명령어**              | **설명**                             |
| -------------------- | ---------------------------------- |
| docker build         | Dockerfile을 기반으로 이미지 생성            |
| \-t my-inference-app | 이미지 이름 태그 지정                       |
| .                    | 현재 폴더를 context로 사용 (Dockerfile 위치) |

- 정리하자면
    -  Cloud Run은 GCE나 C3같은 컴퓨팅 인스터스를 쓰진 않는다.
    - Cloud Run 은
        1. Docker 이미지 → Artificial Rrgistry 에서 가져오고
        2. 모델이나 파일 필요하면 → GCE 에서 **불러오고**
        3. 코드 실행은 GCP가 알아서 백엔드에서 서버리스 환경으로 처리

| **단계**           | **설명**                                  | **당신이 말한 표현**                              |
| ---------------- | --------------------------------------- | ------------------------------------------ |
| ① Docker 컨테이너 생성 | 내 코드 + 모델 + 실행 환경을 Dockerfile로 이미지로 만들기 | “모델에 대한 모든 정보를 넣은 도커 컨테이너 만들기”             |
| ② 이미지 빌드 & 푸시    | Docker 이미지로 만들고, Artifact Registry로 푸시  | “배포는 빌드하고 푸시하는 행동”                         |
| ③ Cloud Run 배포   | 푸시한 이미지를 Cloud Run이 받아서 서비스 생성          | “Cloud Run이 Artifact Registry에 저장된 이미지 실행” |
| ④ 사용자 요청 처리      | 사용자가 업로드한 이미지 → 내 모델이 판독 → 결과 응답        | “사용자가 POST한 곳으로 결과를 출력해주는 것”               |

- Cloud Run + Artificial Registry는 따로 존재해서 함꼐 동작한다
    - **Artifact Registry**는:

        🔹 당신이 만든 **도커 이미지(=코드 + 모델)**를 저장해두는 **저장소**

    - **Cloud Run**은:

        🔹 그 이미지를 가져와서 **사용자 요청이 올 때마다 자동으로 실행해주는 서버리스 서비스**

- 여기서 Cloud Run은 서버 관리 안 해도 되는 서버 ( 사용자가 직접 만들지 않는 “서버리스(serverless)” 임)
- Docker는 코드를 "클라우드에 올리기 위한 형태임(도구, 수단)"