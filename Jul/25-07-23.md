# 오늘 내가 배운 것들(Today I Learned)

- 오늘(수)은 부하테스트 1일차이다.

---

**<AI>**

- 테스트 시나리오 정의 : 입력값과 기대 결과 예측해보기
  - 전제조건이 무엇인지
  - 각 단계별로 어떤 행동을 수행해야 하는지
  - 어떤 결과를 기대하는지
  - 어떤 예외 상황이 발생할 수 있는지

- 리소스 : ts.amall x30 로 시행

![IMG_5626.heic](https://resv2.craft.do/user/full/641ffdb9-6693-37da-6dbd-e78e1756c2de/doc/3c17d71c-25ef-2249-36c5-6ac2c9747d25/E8B9E53B-4560-4A45-9E89-98A2FB4A6C0D_2/uIfehKWwDmyfi3uezNiGvxKEuSTVZKkOJNMeBBArnckz/IMG_5626.heic)

![IMG_5627.heic](https://resv2.craft.do/user/full/641ffdb9-6693-37da-6dbd-e78e1756c2de/doc/3c17d71c-25ef-2249-36c5-6ac2c9747d25/97D5D33E-48CD-4DCA-8E36-C912D7272E2B_2/Ou7jyLJE6cYp7FOy2OpIfWDTPumyPsupfoz9rDutbAcz/IMG_5627.heic)

![IMG_5629.heic](https://resv2.craft.do/user/full/641ffdb9-6693-37da-6dbd-e78e1756c2de/doc/3c17d71c-25ef-2249-36c5-6ac2c9747d25/7BCA0B7C-0091-4A74-A9D4-60FB5450B987_2/FWyNbXx1ejElLNWQT65OLPcmvxyyC1RUOSWzRmDqNwcz/IMG_5629.heic)

![IMG_5630.heic](https://resv2.craft.do/user/full/641ffdb9-6693-37da-6dbd-e78e1756c2de/doc/3c17d71c-25ef-2249-36c5-6ac2c9747d25/F01E9B56-A769-4B13-AA72-20795B505EFF_2/ci5bqxbbUJ2ZYpT39OEhTfifjdVwtyRn0FV7n7dd1eoz/IMG_5630.heic)

![IMG_5633.heic](https://resv2.craft.do/user/full/641ffdb9-6693-37da-6dbd-e78e1756c2de/doc/3c17d71c-25ef-2249-36c5-6ac2c9747d25/9A9972FA-78D4-44E9-83A3-13ACFE69DC6D_2/yk7zRgDkipkFM4ppy03jML1F29PuRZMgVHCoX8oNj5sz/IMG_5633.heic)

# 실시간 채팅 애플리케이션 사용 설명서

## 서버 개요

- 이 애플리케이션은 **실시간 채팅 서버**로 다음과 같은 구조

### 서버 구성

- **Frontend Server**: Next.js (포트 3000) - 웹 인터페이스
- **Backend Server**: Node.js + Express (포트 5001) - API 및 WebSocket
- **MongoDB**: 채팅 데이터 저장 (포트 27017)
- **Redis**: 실시간 세션 관리 (포트 6379)

## 서버 실행 방법

### 1. 개발 모드 실행

```Bash
# 프로젝트 디렉토리로 이동
cd 15-ktb-BootcampChat

# Frontend + Backend 동시 실행
npm run dev
```

### 2. 개별 서버 실행

```Bash
# Backend만 실행
npm run dev:backend

# Frontend만 실행  
npm run dev:frontend
```

### 3. 프로덕션 모드 실행

```Bash
# Frontend 빌드
npm run build

# 빌드된 애플리케이션 실행
npm start
```

## 서버 종료 방법

### 1. 일반 종료

터미널에서 `Ctrl + C` 로 종료

### 2. 강제 종료

```Bash
# 프로세스 검색 및 종료
ps aux | grep "npm run dev"
kill -9 [PID]

# 또는 모든 Node.js 프로세스 종료
pkill -f "npm run dev"
pkill -f "nodemon"
pkill -f "next dev"
```

### 3. 포트별 종료

```Bash
# 특정 포트 사용 프로세스 종료
lsof -ti:3000 | xargs kill -9  # Frontend
lsof -ti:5001 | xargs kill -9  # Backend
```

## 서버 상태 확인

### 실행 중인 서버 확인

```Bash
# Node.js 프로세스 확인
ps aux | grep -E "(node|npm)" | grep -v grep

# 포트 사용 상태 확인
lsof -i :3000  # Frontend
lsof -i :5001  # Backend
lsof -i :27017 # MongoDB
lsof -i :6379  # Redis
```

### 서비스 상태 확인

```Bash
# MongoDB 상태
brew services list | grep mongodb

# Redis 상태  
brew services list | grep redis
```

## 접속 방법

### 웹 브라우저 접속

- Frontend: [http://localhost:3000](http://localhost:3000)
- Backend API: [http://localhost:5001/api](http://localhost:5001/api)

### API 테스트

```Bash
# 서버 상태 확인
curl http://localhost:5001/api/health

# WebSocket 연결 테스트 (브라우저 콘솔에서)
const socket = io('http://localhost:5001');
```

## 주요 기능

### 실시간 채팅

- WebSocket (Socket.IO) 기반 실시간 통신
- 마크다운 지원
- 파일 첨부 (이미지, 동영상, PDF 등)
- 이모지 리액션
- 멘션 기능 (@사용자)

### AI 챗봇

- @wayneAI, @consultingAI 멘션으로 호출
- OpenAI API 연동

### 보안 기능

- JWT 기반 인증
- 비밀번호 암호화
- 세션 관리

## 부하테스트 포인트

이 서버를 부하테스트할 때 중요한 지점들:

### 1. WebSocket 연결 부하

```Bash
# 동시 연결 수 테스트
artillery quick --count 100 --num 10 http://localhost:3000
```

### 2. 메시지 전송 부하

```Bash
# 초당 메시지 수 (RPS) 테스트
artillery quick --count 50 --num 20 http://localhost:5001/api/messages
```

### 3. 파일 업로드 부하

```Bash
# 대용량 파일 동시 업로드
curl -X POST -F "file=@test.jpg" http://localhost:5001/api/upload
```

## 환경 변수 설정

- 해당 내용은 보안이슈로 생략.

## 패키지 설치 및 초기 설정

```Bash
# 프로젝트 클론
git clone https://github.com/100-hours-a-week/15-ktb-BootcampChat
cd 15-ktb-BootcampChat

# 루트 디렉토리에서 모든 패키지 설치
npm install  # concurrently 설치
npm run setup  # frontend와 backend 패키지 설치
```

## 사전 요구사항

### macOS 환경

```Bash
# Node.js 18 설치 (nvm 사용)
nvm install 18
nvm use 18

# MongoDB 설치
brew install mongodb-community@7.0
brew services start mongodb/brew/mongodb-community@7.0

# Redis 설치
brew install redis
brew services start redis

# PM2 전역 설치
npm install -g pm2
```

## 문제 해결

### 서버 연결 실패 시

1. 포트 충돌 확인
2. 환경 변수 확인
3. MongoDB/Redis 실행 상태 확인
4. 방화벽 설정 확인

### 성능 최적화

- PM2로 클러스터 모드 실행
- Redis 클러스터 구성
- MongoDB 인덱스 최적화
- CDN 사용 (정적 파일)

---

## E2E 테스트 정의

> E2E 테스트(End-to-End Testing)는 실제 사용자 관점에서 애플리케이션의 전체 워크플로우를 처음부터 끝까지 테스트하는 방법

- 예시:

```bash
사용자가 쇼핑몰에서 상품을 구매하는 과정:
로그인 → 상품 검색 → 장바구니 담기 → 결제 → 주문 완료

E2E 테스트는 이 전체 과정이 실제로 작동하는지 자동으로 확인합니다.
```

## 다른 테스트와의 차이점

- ### 테스트 피라미드

```bash
/\
/E2E\     ← 적은 수, 높은 비용, 실제 사용자 시나리오
/______\
/통합테스트\   ← 중간 수, 중간 비용, 컴포넌트 간 상호작용
/__________\
/  단위테스트  \  ← 많은 수, 낮은 비용, 개별 함수/메서드
```

| **테스트 종류** | **범위**    | **속도** | **비용** | **목적**    |
| ---------- | --------- | ------ | ------ | --------- |
| 단위 테스트     | 개별 함수/메서드 | 빠름     | 낮음     | 로직 검증     |
| 통합 테스트     | 여러 컴포넌트   | 보통     | 보통     | 상호작용 검증   |
| E2E 테스트    | 전체 시스템    | 느림     | 높음     | 사용자 경험 검증 |

## E2E 테스트의 실제 가치

- Before E2E 테스트

```bash
개발자: "로그인 기능 완성했습니다!"
CI/CD: "E2E 테스트 실행 중... ✓ 모든 테스트 통과!"
개발자: "안심하고 배포할 수 있겠네요"
```

- After E2E 테스트

```bash
개발자: "로그인 기능 완성했습니다!"
CI/CD: "E2E 테스트 실행 중... ✓ 모든 테스트 통과!"
개발자: "안심하고 배포할 수 있겠네요"
```

### 실행 결과 예시

> 실제 사용자가 우리 앱을 사용할 때 모든 것이 제대로 작동하는가?

```bash
✓ 사용자 회원가입이 성공해야 함 (2.1s)
✓ 로그인 후 채팅방 목록이 보여야 함 (1.8s)
✓ 실시간 메시지 전송이 작동해야 함 (3.2s)
✓ AI 챗봇이 응답해야 함 (12.4s)
✓ 파일 업로드가 성공해야 함 (4.1s)

총 5개 테스트 통과, 실행 시간: 23.6초
```

### E2E 테스트 시스템 구축 완료 요약

## 📋 프로젝트 개요

- 실시간 채팅 애플리케이션의 포괄적인 End-to-End (E2E) 테스트 시스템을 성공적으로 구축

## 🎯 구성한 테스트 시스템 개요

### **1. 테스트 프레임워크 및 구조**

- **Playwright** 기반 크로스 브라우저 테스트 자동화
- **Socket.IO Client**를 활용한 실시간 통신 테스트
- **MongoDB/Redis** 테스트 환경 격리
- **모듈화된 헬퍼 클래스**로 코드 재사용성 극대화

### **2. 작성된 테스트 카테고리**

#### 🔐 **인증 시스템 테스트** (`auth.spec.js`)

- JWT 기반 회원가입/로그인 플로우
- 토큰 검증 및 갱신 메커니즘
- 중복 로그인 처리 및 세션 관리
- 보안 취약점 (SQL Injection, XSS, Rate Limiting)

#### 🏠 **채팅방 관리 테스트** (`rooms.spec.js`)

- 공개/비밀 채팅방 생성 및 관리
- 권한 기반 접근 제어 (방장/참여자)
- 페이지네이션 및 검색 기능
- 채팅방 수정/삭제 권한 검증

#### 💬 **실시간 채팅 테스트** (`chat.spec.js`)

- Socket.IO 연결/해제 및 다중 사용자 동시 접속
- 실시간 메시지 송수신 (텍스트, 마크다운, 특수문자)
- AI 챗봇 멘션 및 스트리밍 응답 처리
- 사용자 상태 관리 (입장/퇴장 알림)

#### 📁 **파일 관리 테스트** (`files.spec.js`)

- 다양한 파일 형식 업로드/다운로드
- 파일 크기 제한 및 보안 검증
- 권한 기반 파일 접근 제어
- 파일 미리보기 및 안전한 콘텐츠 처리

#### ⚡ **성능 및 부하 테스트** (`performance.spec.js`)

- API 응답 시간 벤치마크 (인증 < 2초, 채팅방 < 1.5초)
- 동시 사용자 처리 능력 (회원가입, 채팅방 생성, 메시징)
- 메모리 사용량 및 누수 방지 검증
- 데이터베이스 성능 및 페이지네이션 효율성

### **3. 핵심 헬퍼 클래스**

#### **ApiHelper** - REST API 테스트 자동화

```javascript
// 사용자 관리
const user = await apiHelper.registerUser();
const loginResult = await apiHelper.loginUser(credentials);  

// 채팅방 관리
const room = await apiHelper.createRoom(roomData, token, sessionId);
const rooms = await apiHelper.getRooms(token, sessionId);
```

#### **SocketHelper** - 실시간 통신 테스트

```javascript
// Socket 연결 및 채팅방 참여
await socket.connect(token, sessionId);
await socket.joinRoom(roomId);

// 메시지 및 AI 통신
await socket.sendMessage(roomId, content);
const aiResponse = await socket.waitForAIResponse();
```

## 🔍 논리적 구성 근거

### **1. 계층적 테스트 설계**

- **단위 기능별 분리**: 각 핵심 기능을 독립적인 테스트 스펙으로 구성
- **의존성 순서**: 인증 → 채팅방 → 실시간 통신 → 파일 → 성능 순으로 테스트
- **격리된 환경**: 각 테스트는 독립적인 데이터베이스와 상태를 사용

### **2. 실전 시나리오 중심**

- **사용자 여정 시뮬레이션**: 실제 사용자가 경험하는 전체 플로우 검증
- **예외 상황 포함**: 정상 케이스뿐만 아니라 에러 처리 및 보안 검증
- **성능 기준 설정**: 실제 운영 환경에서 요구되는 성능 목표 정의

### **3. 확장 가능한 아키텍처**

- **모듈화된 헬퍼**: 새로운 기능 추가 시 쉽게 확장 가능
- **설정 중앙화**: 글로벌 설정으로 테스트 환경 일관성 보장
- **CI/CD 친화적**: 자동화된 테스트 실행 및 리포팅

### **4. 포괄적 검증 범위**

- **기능적 요구사항**: 모든 핵심 비즈니스 로직 검증
- **비기능적 요구사항**: 성능, 보안, 확장성 검증
- **통합 테스트**: 서로 다른 컴포넌트 간 상호작용 검증

## 📊 성능 기준 및 품질 지표

| 테스트 영역 | 목표 기준 | 검증 항목 |
|------------|-----------|----------|
| **인증** | < 2초 응답 | JWT 토큰 검증, 세션 관리 |
| **채팅방** | < 1.5초 응답 | CRUD 작업, 권한 제어 |
| **실시간** | < 100ms 메시지 | Socket.IO 통신, 브로드캐스트 |
| **파일** | < 3초 업로드 | 다양한 형식, 보안 검증 |
| **동시성** | 100명 동시 | 메모리 누수 없음, 안정성 |

## 🚀 실행 및 활용 방법

### **즉시 실행 가능**

```bash
# 전체 테스트 실행
npm run test:e2e

# 특정 테스트만 실행
npx playwright test auth.spec.js

# 성능 모니터링
npm run test:e2e:report
```

### **개발 워크플로우 통합**

1. **기능 개발** → **해당 테스트 실행** → **성능 검증** → **배포**
2. **CI/CD 파이프라인**에서 자동 테스트 실행
3. **성능 메트릭 모니터링**으로 지속적 품질 관리

## 📁 생성된 파일 목록

```other
tests/e2e/
├── helpers/
│ ├── api-helper.js # REST API 테스트 헬퍼 클래스
│ └── socket-helper.js # Socket.IO 테스트 헬퍼 클래스
├── auth.spec.js # 인증 시스템 E2E 테스트
├── rooms.spec.js # 채팅방 관리 E2E 테스트
├── chat.spec.js # 실시간 채팅 E2E 테스트
├── files.spec.js # 파일 관리 E2E 테스트
├── performance.spec.js # 성능 및 부하 테스트
├── global-setup.js # 글로벌 테스트 설정
└── global-teardown.js # 글로벌 테스트 정리

프로젝트 루트/
├── playwright.config.js # Playwright 설정 파일
├── package.json # 테스트 스크립트 추가
├── README_E2E_TESTS.md # 상세 E2E 테스트 가이드
└── E2E_TEST_SUMMARY.md # 이 문서 (구축 완료 요약)
```

## 🎯 테스트 커버리지

### **기능별 테스트 범위**

- ✅ **인증 시스템**: 회원가입, 로그인, 토큰 관리, 보안 검증
- ✅ **채팅방 관리**: 생성, 참여, 권한, 검색, 페이지네이션
- ✅ **실시간 통신**: Socket.IO 연결, 메시징, AI 챗봇, 상태 관리
- ✅ **파일 시스템**: 업로드, 다운로드, 미리보기, 보안 검증
- ✅ **성능 테스트**: 응답 시간, 동시 사용자, 메모리 관리

### **품질 보증 요소**

- 🔒 **보안 테스트**: SQL Injection, XSS, 파일 업로드 보안
- ⚡ **성능 테스트**: 응답 시간, 동시 접속, 메모리 누수 방지
- 🔄 **안정성 테스트**: 에러 처리, 재연결, 예외 상황 대응
- 🎯 **사용성 테스트**: 실제 사용자 시나리오 시뮬레이션

## 🔧 구현된 주요 기능

### **1. 자동화된 테스트 환경**

- 독립된 테스트 데이터베이스 (`bootcampchat_test`)
- Redis 테스트 환경 분리
- 테스트 전후 자동 데이터 정리
- 브라우저별 크로스 테스트 지원

### **2. 실시간 통신 테스트**

- Socket.IO 연결/해제 자동화
- 다중 사용자 동시 접속 시뮬레이션
- AI 챗봇 스트리밍 응답 검증
- 메시지 큐 및 이벤트 처리 검증

### **3. 성능 벤치마킹**

- API 응답 시간 측정 및 임계값 설정
- 동시 사용자 처리 능력 검증
- 메모리 사용량 모니터링
- 데이터베이스 쿼리 성능 측정

### **4. 보안 검증**

- 인증 토큰 무결성 검증
- 권한 기반 접근 제어 테스트
- 파일 업로드 보안 검증
- Rate Limiting 및 DDoS 방어 테스트

## 🎉 기대 효과

### **1. 개발 효율성 향상**

- 자동화된 테스트로 수동 테스트 시간 대폭 단축
- 리그레션 테스트 자동화로 안전한 코드 변경
- CI/CD 파이프라인 통합으로 배포 안정성 확보

### **2. 코드 품질 보장**

- 모든 핵심 기능에 대한 체계적 검증
- 성능 기준 설정으로 지속적 품질 관리
- 보안 취약점 사전 차단

### **3. 운영 안정성 확보**

- 실제 사용 시나리오 기반 테스트로 예상치 못한 버그 방지
- 부하 테스트로 서버 용량 계획 및 최적화
- 장애 상황 대응 능력 검증

### **4. 확장성 및 유지보수성**

- 모듈화된 테스트 구조로 새 기능 테스트 쉽게 추가
- 명확한 테스트 문서화로 팀 내 지식 공유
- 표준화된 테스트 패턴으로 일관된 품질 유지

## 🚀 다음 단계 권장사항

### **1. 즉시 실행**

```bash
# 패키지 설치
npm install  

# MongoDB & Redis 실행 확인
mongod --dbpath ~/data/db
redis-server

# 전체 E2E 테스트 실행
npm run test:e2e
```

### **2. CI/CD 파이프라인 통합**

- GitHub Actions, Jenkins 등에 테스트 자동 실행 설정
- 테스트 실패 시 배포 중단 정책 수립
- 성능 메트릭 모니터링 대시보드 구축

### **3. 지속적 개선**

- 실제 운영 데이터 기반 테스트 시나리오 업데이트
- 성능 임계값 조정 및 최적화
- 새로운 기능 개발 시 해당 테스트 케이스 추가