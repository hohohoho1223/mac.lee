# 오늘 내가 배운 것들(Today I Learned)

- 피드백 모델에서 RQ 워커 도입으로 FastAPI에서의 모델 로드가 아닌 별개의 RQ 워커 서버에서 모델로드가 이뤄지는 중임
- 그래서 첫 피드백 요청이 들어오면 메모리에 모델 로드부터 함ㅠ

---

## **과거 구조와 차이점**

| **항목**    | **RQ 도입 전 (기존)** | **RQ 도입 후 (현재)** |
| --------- | ---------------- | ---------------- |
| 모델 로딩 주체  | FastAPI 내부       | RQ 워커 내부         |
| 피드백 생성    | FastAPI에서 직접 실행  | RQ 워커에서 실행       |
| 결과 콜백     | FastAPI가 직접 호출   | RQ 워커가 직접 호출     |
| 모델 메모리 관리 | FastAPI 메모리 상주   | RQ 워커에만 상주       |

### **흐름 예시 (지금 구조)**

1. **클라이언트 → FastAPI**
    - 클라이언트가 /ai/feedback 엔드포인트로 요청
    - FastAPI는 요청을 Redis의 feedback 큐에 enqueue함
2. **FastAPI → Redis**
    - 작업은 Redis에 큐로 저장됨 (작업 대기)
3. **RQ 워커 → Redis**
    - RQ 워커는 Redis 큐를 실시간으로 감시하다가
    - 작업이 생기면 generate_feedback_task() 실행
4. **RQ 워커 → LLM**
    - 내부에서 모델 로드 (shared_model)
    - 피드백 텍스트 생성
5. **RQ 워커 → Spring 서버**
    - 생성된 결과를 [https://springboot.dev-leafresh.app/api/members/feedback/result로](https://springboot.dev-leafresh.app/api/members/feedback/result%EB%A1%9C) POST
    - **RQ는 서버가 아니라** “FastAPI 서버가 던진 작업을 Redis 큐로부터 받아 처리하는 워커 프로세스”이다.

```plaintext
[FastAPI 서버] ---enqueue---> [Redis] <---listen--- [RQ 워커]
                                           |
                                           └── 모델 로드 및 생성 → Spring으로 결과 POST
```

1. RQ 워커는 “서버”가 아니라 “백그라운드 작업자 프로세스”입니다
    - rq worker feedback은 **FastAPI 서버와 별개로 실행되는 프로세스**입니다.
    - 이 워커는 Redis 큐를 **계속 감시(polling)** 하면서, 새로운 작업(Job)이 들어오면 실행합니다.

    즉, RQ 워커는 **“서버”처럼 API 요청을 수신하거나 listen하지는 않지만**,

    **Job 처리라는 작업 처리 단위에 대해선 독립된 실행 환경을 갖습니다.**

---

2. 하지만 “모델 로드”는 반드시 필요함
    - 피드백 생성은 LLM이 필요하므로, generate_feedback_task()에서 **Mistral 모델을 반드시 불러와야 함**.
    - 따라서 RQ 워커는 **작업(Job)을 처리할 수 있도록 모델을 로드하고, 토크나이저도 초기화**해야함
      > 즉, FastAPI와 모델을 공유하지 않고, **자기 내부적으로 모델을 다시 로드하는 구조**임

---

3. 왜 이게 가능한가? → RQ 워커도 “독립 실행 환경”이기 때문
    - `rq worker feedback` 명령어는 결국 **Python 인터프리터를 실행하는 또 다른 독립 실행체임**
    - generate_feedback_task()가 실행되면, 그 안에서 다음처럼 호출됨:
        - FeedbackModel() → shared_model = SharedMistralModel() → 모델 로드
    - 이건 **서버 실행이 아니라 코드 실행임**
      > 즉, “서버가 있다”는 개념이 아니라, **코드 상에 모델이 로드되는 흐름**일 뿐

---

4. 그럼 왜 FastAPI랑 모델을 공유하지 않나?
    - 프로세스가 다르기 떄문임.

| **항목**    | **FastAPI**         | **RQ 워커**                 |
| --------- | ------------------- | ------------------------- |
| 실행 주체     | API 서버 (예: uvicorn) | 백그라운드 프로세스 (예: rq worker) |
| 모델 로드 시점  | 서버 실행 시             | 워커 실행 시                   |
| 모델 공유 가능성 | 동일 프로세스 내에서만 공유 가능  | 공유 불가 (프로세스 분리)         |