# 오늘 내가 배운 것들(Today I Learned)

- 오늘은 SSE 도입을 위해 통신 작업을 하였다.(SSE_통신작업_1)

---

- 근데 테스트 서버가 연결이 계속 안돼서 이유가 뭘까 찾아보았다.
- 아래는 스크린샷 이다.

![Image.png](https://resv2.craft.do/user/full/641ffdb9-6693-37da-6dbd-e78e1756c2de/doc/3c17d71c-25ef-2249-36c5-6ac2c9747d25/243791B6-7A6F-43E9-B981-F5135387F477_2/BrFxuDdew7oorDDByFCAkXjf9edszFe3jLAX67GJa7cz/Image.png)

- 분명 내부 외부 IP 주소 다 열려있다.
- GPT-4o 답변은 다음과 같았다.
  > “네, GCP Compute Engine UI에서 내부 IP와 외부 IP 주소가 모두 표시되는 것은 맞습니다. VM 인스턴스 자체에는 외부에서 접근할 수 있는 공인 IP 주소(35.216.82.57)가 할당되어 있고, 네트워크 트래픽이 이 IP를 통해 해당 VM으로 라우팅될 수 있다는 것을 의미합니다.” 
  > "하지만 이것과 VM 인스턴스 내부에서 실행 중인 서버 애플리케이션이 외부 IP 주소로 들어오는 연결을 수신 대기하고 있는지 여부는 별개의 문제입니다.이전에 확인했던 netstat -tuln | grep 8000 명령어의 출력 결과를 다시 한번 봐주세요.”

```markdown
tcp        0      0 127.0.0.1:8000          0.0.0.0:*               LISTEN
```

- 이 결과에서 중요한 부분: `127.0.0.1:8000`
  > “GCP UI에 표시되는 외부 IP 주소는 VM 인스턴스에 할당된 '도로명 주소'와 같습니다. 이 주소를 통해 외부에서 VM 인스턴스까지 접근할 수 있는 경로가 있다는 의미입니다.”
  > “하지만 netstat 결과의 `127.0.0.1:8000 LISTEN` 은 VM 인스턴스 내부에 있는 서버 애플리케이션이 '자신이 살고 있는 집 안(로컬호스트)'에서만 8000번 포트로 오는 요청을 기다리고 있다는 의미입니다. 외부 '도로명 주소'로 아무리 우편물이 와도, 집 문을 잠그고 집 안에서만 기다리고 있는 것과 같습니다.”

![Image.png](https://resv2.craft.do/user/full/641ffdb9-6693-37da-6dbd-e78e1756c2de/doc/3c17d71c-25ef-2249-36c5-6ac2c9747d25/D9803003-807C-450C-8C23-A211924D820C_2/3N0uqcijjqkDP8dALP77BKIeOTsxHLykbZaYuaLYRM8z/Image.png)

- 127.0.0.1:8000 서버로 열었었음 ㅇㅇ
  > "즉, 외부 IP(35.216.82.57)를 통해 VM에 트래픽이 도달하더라도, VM 내부의 서버 애플리케이션이 127.0.0.1 (로컬호스트)에서만 연결을 수신 대기하고 있기 때문에 해당 트래픽을 처리하지 못하고 타임아웃이 발생하는 것입니다.”

  > “이 문제를 해결하려면 서버 애플리케이션이 모든 네트워크 인터페이스(0.0.0.0)에서 연결을 수신하도록 설정해야 합니다. 그래야 외부 IP 주소를 통해 들어오는 요청도 서버 애플리케이션이 받아들일 수 있습니다.”

  > “이전에 안내드린 것처럼, uvicorn 서버를 시작할 때 --host 0.0.0.0 옵션을 추가하여 실행해야 합니다.”

- 아 그럼 현재 서버를 "내부에서만 접근 가능”하도록 띄웠던거였다.
- 근데 여기서 중요한 것은 “GCP 방화벽 설정임". 서버 애플리케이션이 `0.0.0.0` 으로 수신 대기 하더라도, GCP 방화벽 규격이 8000번 포트로의 외부 인바운드 트래픽을 허용하고 있지 않다면 여전히 외부에서 접근 불가함
- 확인해보자

---

###  여기서 잠깐, 서버 “애플리케이션" 이라고 칭하는 이유는?

- “서버”라는 용어는 여러가지 의미로 사용될 수 있다.
  - 하드웨어 서버: 실제 물리적인 컴퓨터나 VM 인스턴스 자체를 의미 
  - 소프트웨어 서버: 네트크 요청을 받아 처리하는 "특정 소프트웨어 프로그램”(예: 웹 서버, DB 서버 등) -> 나는 지금 FastAPI & Uvicorn 서버 인 경우
- “서버 애플리케이션” 이라고 하는 표현하는 것은 이 둘을 명확히 구분하여, VM 인스턴스라는 하드웨어 위에서 실행되고 있는 FastAPI + Uvicorn 들의 네트워크 연결을 처리하는 것에 초점을 맞추기 때문임.

---

- GCP 방화벽 규칙 확인 

![Image.png](https://resv2.craft.do/user/full/641ffdb9-6693-37da-6dbd-e78e1756c2de/doc/3c17d71c-25ef-2249-36c5-6ac2c9747d25/57528E5F-47D3-49B2-8E0A-985C0E610816_2/E6Ll3koi32K093xdhHvpkYJL1IyHupGzoeQHMeSW0DAz/Image.png)

  > “ 여기서 leafresh-vpc-allow-custom 규칙이 "전체 허용"으로 되어 있지만, 이것이 8000번 포트의 TCP 트래픽을 포함하는지는 추가 확인이 필요합니다. 만약 이 규칙이 특정 태그나 서비스 계정에만 적용되고 해당 VM 인스턴스에 적용되지 않거나, 혹은 특정 프로토콜/포트만 허용하는 것이라면 8000번 포트 트래픽이 차단될 수 있습니다.”
  
  > “ 결론적으로, 현재 방화벽 설정으로는 외부에서 8000번 포트로 접근하는 트래픽이 차단될 가능성이 매우 높습니다. “

###  `—host 0.0.0.0` 이 모든 외부 IP 주소 허용한다는 뜻인가?

-  맞다. `—host 0.0.0.0` 은 서버 애플리케이션이 해당 머신에 할당된 모든 사용 가능한 IP주소(내부 IP,외부 IP)에서 들어오는 연결을 수신대기 하겠다는 의미임.
- 조금 더 자세히 말해보면: 
  - 127.0.0.1 (로컬호스트): 이건 컴퓨터 자신(VM 내부)만을 가리키는 주소임.서버를 127.0.0.1로 띄우면, 해당 VM 안에서만 서버에 접근할 수 있습니다.
  - 0.0.0.0 (모든 인터페이스): 이건 특별한 IP 주소로, 서버가 모든 네트워크 인터페이스에서 요청을 받을 준비가 되었다는 것을 운영체제에 알림 즉, VM에 할당된 공인 IP 주소(예: 35.216.82.57)뿐만 아니라, 내부 사설 IP 주소로 들어오는 요청도 모두 수신할 수 있게 된다

---

### 근데 왜 외부IP 접근이 안될까?

- 문제가 방화벽에 있는지 확실히 확인하기 위해, 로컬 터미널에서 VM의 8000번 포트로 기본적인 TCP 연결이 가능한지 테스트해보자
- 내 로컬 터미널(외부)에서 해당 명령어를 입력 했다. 

```markdown
(base) iwonho@iwonhoui-MacBookPro ~ % nc -zv 35.216.82.57 8000
Connection to 35.216.82.57 port 8000 [tcp/irdmi] succeeded!
```

- TCP연결 되어있다
- 그럼 남은 것은 방화벽 뿐....! 

![Image.png](https://resv2.craft.do/user/full/641ffdb9-6693-37da-6dbd-e78e1756c2de/doc/3c17d71c-25ef-2249-36c5-6ac2c9747d25/69DFC11B-A1A7-4B25-A816-19CA98FD9CC1_2/VricWPflE8Xwsxl9Lc8CzLj8nbT7yyyTnTiyirnwdDAz/Image.png)

- 이렇게 프로토콜 및 포트 tcp:8000으로 지정 해주고 다시 시도해보았다.
- SSE출력 된다 근데 로깅은 찍히는데 파싱 문제가 생겼다 ㅎㅎ

---

- 우리가 해결하려던 문제는 크게 두 가지였다.:
    1. data: data: 중복 현상 (클라이언트에서 SSE 응답을 받을 때)
    2. AttributeError: 'str' object has no attribute 'get' 오류 (서버 로그에서 발생)

1. SSE는 어떻게 작동해야 하는가? (기본 규칙)

>> Server-Sent Events (SSE)는 서버가 클라이언트에 데이터를 실시간으로 보낼 때, 다음과 같은 약속된 형식으로 보냅니다:

```markdown
event: [이벤트_이름]  <-- 선택 사항
data: [데이터_내용]     <-- 필수
[빈 줄]                 <-- 필수 (이벤트의 끝을 알림)
```

- 예를 들어, "토큰 생성"이라는 이벤트에 { "token": "안녕하세요" } 라는 데이터를 보내려면, 서버는 아래와 같이 문자열을 만들어 보내야 한다이

```markdown
event: challenge
data: {"token": "안녕하세요"}
```

### 문제 발생의 원인:  `format_sse_response` 함수 때문?

- 이전 코드에는 `LLM_chatbot_base_info_model.py` 에 `format_sse_response` 라는 함수가 있었다.:

```python
# LLM_chatbot_base_info_model.py 에 있던 함수 (문제의 원인)
def format_sse_response(event: str, data: Dict[str, Any]) -> Dict[str, Any]:
    return {
        "event": event,
        "data": json.dumps(data, ensure_ascii=False) # <-- 여기서 data 딕셔너리를 JSON 문자열로 만듭니다.
    }
```

- 그리고 `get_llm_response` 함수는 이 `format_sse_response`를 호출하여 SSE 이벤트 딕셔너리를 만들었다.

```python
# LLM_chatbot_base_info_model.py (과거 코드)
# ... (중략) ...
yield format_sse_response("challenge", {
    "status": 200,
    "message": "토큰 생성",
    "data": {"token": new_text} # <-- 이 딕셔너리가 format_sse_response로 들어갑니다.
})
# ... (중략) ...
```

- 이 코드가 실행되면 `get_llm_response`는 `chatbot_router.py`로 다음과 같은 딕셔너리를 yield했음:

```python
# LLM_chatbot_base_info_model.py -> chatbot_router.py 로 넘어간 데이터 형태
{
    "event": "challenge",
    "data": "{\"status\": 200, \"message\": \"토큰 생성\", \"data\": {\"token\": \"new_text\"}}" # <-- 'data'가 이미 JSON 문자열입니다!
}
```

- 자, 이제 문제점을 짚어보자:
    1. data: data: 중복문제:
        - chatbot_router.py는 sse_starlette 라이브러리의 EventSourceResponse를 사용합니다.
        - EventSourceResponse는 yield를 통해 {"event": "이벤트_이름", "data": "데이터_내용"} 이런 딕셔너리를 받으면, 자동으로 앞에 event:와 data:를 붙여서 클라이언트에게 전송합니다.
        - 그런데 LLM_chatbot_base_info_model.py에서 이미 data 필드를 JSON 문자열로 만든 것을 chatbot_router.py로 넘김
        - chatbot_router.py는 이 data 필드(이미 JSON 문자열)를 또 다시 EventSourceResponse에 넘겼고, EventSourceResponse는 이 JSON 문자열 앞에 또 data:를 붙여버린 것
        - 그래서 data: {"event": "challenge", "data": "{"token": new_text}"} 이 아니라, data: data: {"status": 200, ...} 이렇게 data:가 두 번 붙는 상황이 발생했습니다.
    2. AttributeError: 'str' object has no attribute 'get' 문제:
        - chatbot_router.py는 get_base_info_llm_response에서 yield된 data_payload 딕셔너리를 받았습니다.
        - data_payload["data"]에는 아까 말한 JSON 문자열이 들어있었습니다.
        - 그런데 chatbot_router.py의 일부 로직에서 이 data_payload["data"]를 마치 딕셔너리처럼 .get() 메서드를 사용하려 했습니다. (예: data_payload["data"].get("some_key"))
        - 하지만 data_payload["data"]는 딕셔너리가 아니라 그냥 문자열이었기 때문에, 문자열에는 .get() 메서드가 없어서 AttributeError가 발생한 것입니다.

### 해결책: format_sse_response 제거 및 직접 yield + json.dumps() 역할 이해

- 그래서 해결책은 이렇다.
    1. `format_sse_response` 함수를 아예 없앴습니다. 이 함수가 data를 미리 JSON 문자열로 만드는 것이 문제의 원인 이었음.
    2. `LLM_chatbot_base_info_model.py` 에서 yield하는 방식을 직접 변경:

```python
    # LLM_chatbot_base_info_model.py (현재 코드)
    yield {
        "event": "challenge",
        "data": json.dumps({ # <-- 핵심! 실제 데이터를 여기서 JSON 문자열로 딱 한 번만 변환합니다.
            "status": 200,
            "message": "토큰 생성",
            "data": {"token": new_text}
        }, ensure_ascii=False)
    }
```

- 이렇게 되면, LLM_chatbot_base_info_model.py는 chatbot_router.py로 다음과 같은 딕셔너리를 yield함:

```python
    # LLM_chatbot_base_info_model.py -> chatbot_router.py 로 넘어간 데이터 형태 (이제는 올바른 형태)
    {
        "event": "challenge",
        "data": "{\"status\": 200, \"message\": \"토큰 생성\", \"data\": {\"token\": \"new_text\"}}" # <-- 여전히 'data'는 JSON 문자열입니다.
    }
```

- 그리고 chatbot_router.py는 이 딕셔너리를 그대로 EventSourceResponse에 yield합니다:

```python
    # chatbot_router.py (현재 코드)
    for data_payload in get_base_info_llm_response(prompt):
        # ... (중략) ...
        yield data_payload # <-- 받은 딕셔너리를 그대로 다시 yield
```

- 이제 EventSourceResponse는 이 딕셔너리를 받아서 약속된 SSE 형식(event:, data:)으로 단 한 번만 변환하여 클라이언트에 보내게 됩니다. 따라서 data: data: 중복이 사라짐.

---

### json.dumps()의 역할이란?

- `json.dumps()`는 Python의 딕셔너리, 리스트, 숫자, 문자열, 불리언, None 등을 JSON 형식의 문자열로 변환해주는 함수입니다. (덤프(dump)는 "쏟아붓다", "내보내다"라는 뜻이죠).
  - 예시: json.dumps({"name": "Alice", "age": 30}) 결과는 '{"name": "Alice", "age": 30}' (따옴표로 감싸진 문자열)
  - data가 JSON 문자열로 반환되는 것은 바로 json.dumps() 때문입니다. SSE 표준에서 data: 뒤에는 문자열이 와야 하기 때문에, Python 객체를 그대로 보낼 수 없고 반드시 json.dumps()를 통해 문자열로 변환해야 합니다.

---

### 요약:

- `format_see_response` 함수가 data를 JSON 문자열로 만드는 역할을 했고, 그 문자열을 EventSourceResponse가 또 다시 data: 접두사를 붙여서 data: data: 중복이 생겼습니다. 그리고 `chatbot_router.py`가 이 JSON 문자열을 딕셔너리처럼 사용하려다 AttributeError가 발생

- 해결책은 `format_sse_response`를 없애고, `LLM_chatbot_base_info_model.py` 에서 yield할 때 {"event": ..., "data": json.dumps(...) } 형태로 직접 만들어서 EventSourceResponse에 넘겨주는 것임. 이렇게 하면 EventSourceResponse가 data: 접두사를 단 한 번만 붙여서 올바른 SSE 형식을 만듬.

---

###  챗봇 프롬프팅 수정: /base-info

- 기존 코드에서는 아래와 같이 챌린지 출력을 해주었음.

![스크린샷 2025-06-11 오후 7.10.23.png](https://resv2.craft.do/user/full/641ffdb9-6693-37da-6dbd-e78e1756c2de/doc/3c17d71c-25ef-2249-36c5-6ac2c9747d25/7B6B9BDE-CC22-4CCE-B60F-0EE092CF765F_2/OxHnZM3mn7qhvDG6QcijWNmRedZm7Rf3uzTmPrcmBG0z/%202025-06-11%20%207.10.23.png)

- `title` 이 좀 식상하다.
- 수정해보자:

    1. `base-info_response_schemas` 정의 수정:

    ```python
    base_response_schemas = [
        ResponseSchema(name="recommend", description="추천 텍스트를 한 문장으로 출력해줘."),
        ResponseSchema(name="challenges", description="추천 챌린지 리스트, 각 항목은 title, description 포함, title은 description 요약문으로 10자 이내로 작성")
    ]
    ```

    2. `base_prompt` 수정:

    ```python
    주의사항:
    1. 모든 속성 이름은 반드시 큰따옴표(")로 둘러싸야 합니다.
    2. 모든 문자열 값도 큰따옴표(")로 둘러싸야 합니다.
    3. recommend 필드에는 {{category}} 관련 추천 문구를 포함해야 합니다.
    ```

    3. recommend 필드에는 "{{category}} 관련 추천 문구를 포함해야 합니다." 추가 했다.

- 결과:

![Image.png](https://resv2.craft.do/user/full/641ffdb9-6693-37da-6dbd-e78e1756c2de/doc/3c17d71c-25ef-2249-36c5-6ac2c9747d25/AC8AFB78-AA5F-4F54-831B-4BC6FA1340D7_2/8IF8o9kDkxrbhNfTKJn5egSSBINILIWGREaDITRxF3Ez/Image.png)

- `recommend` & `title` 의 답변이 확실히 사용자에게 친숙하게 하듯이 수정 되었다.