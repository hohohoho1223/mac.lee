# 오늘 내가 배운 것들(Today I Learned)

- 비동기(코루틴) vs 멀티스레드에 대해 알아보자.

---

- 질문:

> 비동기 방식에서는 여러 스레드들이 요청에 따른 작업에 각각 붙어서 동시에 진행 시키는 것인가?

- 답변:

> **비동기**에서는 스레드들이 동시에 붙는 방식과는 다름. 오히려 하나의 스레드에서 여러 작업을 **병렬처럼 처리하는 방식임.**

- 비동기 vs 멀티스레드

| **구분**     | **비동기 I/O (Async I/O)**    | **멀티스레딩**           |
| ---------- | -------------------------- | ------------------- |
| **스레드 수**  | 보통 1개                      | 여러 개                |
| **작업 방식**  | 이벤트 루프 + 콜백 / await        | 각 스레드가 작업 담당        |
| **동작 흐름**  | 작업 중 I/O 대기 시 다른 작업 처리로 전환 | 스레드가 I/O 작업 대기 시 멈춤 |
| **효율성**    | 메모리 적게 사용, 컨텍스트 스위칭 없음     | 컨텍스트 스위칭 비용 큼       |
| **적합한 상황** | I/O 작업이 많은 서버 (ex. 웹서버)    | CPU 계산이 많은 병렬 작업    |

- 멀티스레드: 작원 여러 명이 각자 맡은 일 처리(사람 . 수많음)
- 비동기: 혼자서 일하지만, 멀티 일처리 능력ㅇㅇ(혼자서 동시에 여러일 하는중)
    > `await` 에서 I/O 대기하는 동안 -> CPU는 다른 코루틴으로 전환해서 처리
    > 이것을 **이벤트 루프(event** **loop)**가 관리함.

- 코루틴(Coroutine): 비동기 함수들이 CPU사용권을 양보하고 서로 번갈아서 실행된다는 뜻
  - 코루틴은 일시 중단 & 재개가 가능한 함수임.
  - 일반 함수: 실행하면 끝날 떄까지 멈추지 않음.
  - 코루틴: await 지점에서 멈췄다가 -> 나중에 다시 이어서 실행됨

### 그럼 CPU에 한해서만 쓰는 방식이야? GPU 환경에서는 안씀?

- 코루틴은 “CPU 환경”에서만 자원을 효울적으로 쓰기 위한 방식임

#### 왜 코루틴은 CPU에서만 주로 쓰일까?

1. 비동기 I/O 처리 목적

> 코루틴은 주로 I/O 대기 시간 중 CPU를 늘리지 않기 위해 등장

- 반면, “GPU”는 보통 연산 중심이라 이런 구조가 무의미함.

#### 그럼 GPU는 어떻게 처리되나?

- GPU는 대개 병렬 연산에 특화된 작업만 처리

> 딥러닝 학습, 매트릭스 연산 등 CUDA 커널이라는 특수한 방식으로 실행

```python
# CPU (Python) -> GPU (연산 요청)
result = model(input_tensor.to("cuda"))
```

- 이건 비동기 코루틴이 아니라, GPU 연산을 "위임”하고 결과를 기다리는 구조
- Pytorch나 Tensorflow도 내부적으로 GPU 요청은 대부분 비동기적 이지만, 코루틴 형태는 아님 

### 요약

| **항목** | **CPU (코루틴 활용)**    | **GPU (코루틴 활용?)**        |
| ------ | ------------------- | ------------------------ |
| 목적     | I/O 대기 중 다른 작업 처리   | 대규모 병렬 연산 처리             |
| 사용 방식  | async/await로 명시적 전환 | CUDA 커널로 비동기 처리 (코루틴 아님) |
| 활용 예시  | 웹 서버, DB 통신, 파일 처리  | 딥러닝 모델 추론, 수치 연산         |

- 코루틴은, "하나의 스레드”가 await을 기점으로 다른 일을 실행

> 진짜 1개의 스레드임ㅋㅋ

```plaintext
[ 하나의 스레드 ]
시간 흐름 →
┌────────────┬────────────┬────────────┐
│ Task A 실행 │  await      │ Task B 실행 │
└────────────┴────────────┴────────────┘
            ↑ CPU 놀리지 않고 다른 코루틴 실행
```

#### 그럼 여러개 스레드(멀티 스레드) + 코루틴은 못 씀?

- 쓸 수 있음
- **코루틴은 비동기 I/O 중심**
- **스레드는 병렬 CPU 연산이나 블로킹 I/O에 활용**

> 즉, 필요에 따라 **코루틴 + 멀티스레드 혼합**도 가능하고, 이것이 실제 웹서버나 모델 서빙에서 흔히 쓰임 

### 요약

- 하나의 스레드에서 코루틴이 작동한다 -> 진짜 OS 스레드 1개만 쓰면서 여러 논리 작업을 번갈아 처리ㅇㅇ

### 아니 근데 스레드가 많으면 병렬로 일 처리 하니까 성능이 더 좋지 않음?

- 맞는 말힘. (CPU-bound 작업에서는 특히)
- 근데 여기서 “코루틴"이 성능 효율성 면에서 좋다고 하는 건 “I/O-bound 작업”일 때임

| **구분**        | **설명**                                          |
| ------------- | ----------------------------------------------- |
| **CPU-bound** | CPU 계산이 많은 작업 (예: 이미지 처리, 수치 연산) → 스레드 병렬 실행 유리 |
| **I/O-bound** | DB, 파일, 네트워크 등 응답 기다리는 작업 → 코루틴 구조가 훨씬 효율적      |

### 그럼 왜 I/O 작업은 코루틴이 유리한가?

- 스레드는 대기 중에도 리소스를 씀(!!!!!)
- 멀티스레드 방식:
  - 스레드 1000개 생성
  - 각 스래드는 응답을 기다리며 메모리 점유 + 컨텍스트 스위칭 발생
    > 컨텍스트 스위칭: CPU가 현재 작업 중인 스레드의 상태를 저장하고 다른 닥업 전환할 때 그 상태를 불러오는 행위
    > 걍 한마디로 지금 하던 일 멈추고 다른일 바꿀 준비 하는것(ADHD마냥)
  - 리소스 과잉 소비
- 코루틴 방식:
  - 스레드 1개
  - 1000개의 요청을 혼자서 처리
  - await 상태면 CPU 반환 -> 다음 코루틴을 처리
  - 스케줄링 오버헤드 없음, 메모리도 적음

### 그럼 코루틴 방식에서 await상태면 CPU 변환 후, 다음 코루틴을 처리 한다는데, 기존에 사용하던 스레드를 재탕하는거임?

- ㅇㅇ 코루틴 구조에서는 "애초에 원래부터 스레드가 1개 뿐"임
- 즉, 999개 스레드가 꺼져 있는게 아니라 **애초에 존재하지도 않음**