# 오늘 내가 배운 것들(Today I Learned)

- v.1.4.0 챗봇 리스폰스바디에 category& label 추가— 1.4.0인데 머지는 v1.2.0로함 ㅋㅋ..
- 기능 추가 될 때마다 커밋하고 머지 했어야 했는데 건너뛰고 다른 기능 넣어서 그냥 둘이 합치기로 함..ㅎㅎ

---

## 1. 피드백 기능 추가 (api)

- `main.py` 수정
- 글로벌 예외 핸들러 등록
    - FastAPI는 앱 전반적으로 해당 예외가 발생했을 때 이 함수를 자동 호출
    - global_validation_handler는 라우팅 역할만 수행
    - 실제 응답 포맷, 메시지 커스터마이징, 로그 출력 등은 각 라우터에 정의된 개별 핸들러 함수가 담당
- 비스트리밍 방식 구현
- 비동기 처리
- BackgroundTasks 도입
    - FastAPI의 BackgroundTasks를 사용하여 비동기 처리
    - 클라이언트는 즉시 응답을 받고, 실제 처리는 백그라운드에서 진행
    - 202 Accepted 상태 코드로 비동기 처리 상태 명시
- httpx 비동기 HTTP 클라이언트 사용
    - httpx의 비동기 클라이언트 사용
    - async/await 패턴으로 비동기 HTTP 요청 처리
    - 콜백 전송 시 다른 작업 블로킹 없음

## 2. 챗봇 response body 구조 수정(category&label)

- 순환 참조 문제 해결
- ENV_KEYWORDS 와 BAD_WORDS 및 label_mapping은 두 파일에서 공통적으로 사용되기 때문에 별도의 파일(chatbot_constants.py) 에 정의해두고, 양쪽에서 가져오도록 구성

# 3. 카테고리 처리 로직 개선 

## 1. 카테고리 상태 관리

### 1.1 카테고리 필드 구조

```python
{
"category": base_info_category, # 현재 선택된 카테고리
"base_category": base_info_category # 원본 카테고리
}
```

### 1.2 카테고리 변경 처리

```python
# 카테고리 변경 처리
category_changed = False

# 1. "아무거나" 등의 요청 처리
if any(keyword in query.lower() for keyword in ["아무", "아무거나", "다른거", "새로운거", "딴거", "다른"]):
available_categories = [cat for cat in label_mapping.keys() if cat != state["category"]]
if not available_categories:
available_categories = list(label_mapping.keys())

sampled_category = random.choice(available_categories)
state["category"] = sampled_category
category_changed = True

# 2. 특정 카테고리 요청 처리
else:
for category in label_mapping.keys():
if category in query:
    state["category"] = category
    category_changed = True
    break

# 3. base-info 카테고리 처리
if not category_changed and base_info_category and state["category"] != base_info_category:
state["category"] = base_info_category
category_changed = True
```

## 2. 라우터에서의 카테고리 처리

### 2.1 최신 카테고리 반영

```python
# 현재 세션의 최신 카테고리 가져오기
if req.sessionId in conversation_states:
current_category = conversation_states[req.sessionId]["category"]

if current_category in label_mapping:
eng_label, kor_label = label_mapping[current_category]

# 챌린지 데이터에 현재 카테고리 정보 업데이트
if "challenges" in parsed:
    for challenge in parsed["challenges"]:
        challenge["category"] = eng_label
        challenge["label"] = kor_label
```

## 3. 주요 개선사항

1. **카테고리 변경 추적**
    - `category_changed` 플래그를 통한 변경 상태 관리
    - 중복 변경 방지
1. **카테고리 우선순위**
    - "아무거나" 요청 > 특정 카테고리 요청 > base-info 카테고리
    - 명시적 요청이 우선 처리됨
1. **응답 데이터 일관성**
    - 카테고리 변경 시 챌린지 데이터의 `category`와 `label` 자동 업데이트
    - 라우터에서 중복 처리 제거
1. **에러 처리 강화**
    - 카테고리 유효성 검사
    - 잘못된 카테고리 값 처리

## 4. 카테고리 2개 설정 이유

1. **현재 카테고리 (`category`)**
    - 사용자의 현재 요청에 따라 동적으로 변경
    - "아무거나" 요청이나 특정 카테고리 요청에 따라 업데이트
    - 챌린지 추천에 직접적으로 사용
1. **원본 카테고리 (`base_category`)**
    - 사용자가 처음 선택한 카테고리 보존
    - 카테고리 변경 이력 추적
    - 필요한 경우 원본 카테고리로 복원 가능
    - 사용자 선호도 분석에 활용 가능