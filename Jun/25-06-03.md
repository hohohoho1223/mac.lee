# 오늘 내가 배운 것들(Today I Learned)

- v.1.4.0 챗봇 리스폰스바디에 category& label 추가— 1.4.0인데 머지는 v1.2.0로함 ㅋㅋ..
- 기능 추가 될 때마다 커밋하고 머지 했어야 했는데 건너뛰고 다른 기능 넣어서 그냥 둘이 합치기로 함..ㅎㅎ

---

## 1. 피드백 기능 추가 (api)

- `main.py` 수정
- 글로벌 예외 핸들러 등록
    - FastAPI는 앱 전반적으로 해당 예외가 발생했을 때 이 함수를 자동 호출
    - global_validation_handler는 라우팅 역할만 수행
    - 실제 응답 포맷, 메시지 커스터마이징, 로그 출력 등은 각 라우터에 정의된 개별 핸들러 함수가 담당
- 비스트리밍 방식 구현
- 비동기 처리
- BackgroundTasks 도입
    - FastAPI의 BackgroundTasks를 사용하여 비동기 처리
    - 클라이언트는 즉시 응답을 받고, 실제 처리는 백그라운드에서 진행
    - 202 Accepted 상태 코드로 비동기 처리 상태 명시
- httpx 비동기 HTTP 클라이언트 사용
    - httpx의 비동기 클라이언트 사용
    - async/await 패턴으로 비동기 HTTP 요청 처리
    - 콜백 전송 시 다른 작업 블로킹 없음

## 2. 챗봇 response body 구조 수정(category&label)

- 순환 참조 문제 해결
- ENV_KEYWORDS 와 BAD_WORDS 및 label_mapping은 두 파일에서 공통적으로 사용되기 때문에 별도의 파일(chatbot_constants.py) 에 정의해두고, 양쪽에서 가져오도록 구성

# 3. 카테고리 처리 로직 개선 

## 1. 카테고리 상태 관리

### 1.1 카테고리 필드 구조

```python
{
"category": base_info_category, # 현재 선택된 카테고리
"base_category": base_info_category # 원본 카테고리
}
```

### 1.2 카테고리 변경 처리

```python
# 카테고리 변경 처리
category_changed = False

# 1. "아무거나" 등의 요청 처리
if any(keyword in query.lower() for keyword in ["아무", "아무거나", "다른거", "새로운거", "딴거", "다른"]):
available_categories = [cat for cat in label_mapping.keys() if cat != state["category"]]
if not available_categories:
available_categories = list(label_mapping.keys())

sampled_category = random.choice(available_categories)
state["category"] = sampled_category
category_changed = True

# 2. 특정 카테고리 요청 처리
else:
for category in label_mapping.keys():
if category in query:
    state["category"] = category
    category_changed = True
    break

# 3. base-info 카테고리 처리
if not category_changed and base_info_category and state["category"] != base_info_category:
state["category"] = base_info_category
category_changed = True
```
